<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>Mp4Box.js file metadata extraction</title>

	<script src="mp4box.simple.min.js"></script>
<!-- 	<script src="mp4box.simple.js"></script> -->
<!-- 	<script src="mp4box.all.js"></script> -->
</head>
<body>

<p>Choose mp4 files:</p>
<input type="file" id="files" name="files[]" accept="video/mp4" />
<hr/>

<textarea id="output"></textarea>
<hr/>
<p>Bitrate: <span id="bitratetext"></span> kbps</p>
<p>Audio Codec: <span id="audiotext"></span></p>
<p>Video Codec: <span id="videotext"></span></p>
<p id="checkmsg" style="color:red;"></p>


<script type="application/ecmascript">

	document.getElementById('files').addEventListener('change', function(evt){
		var file = evt.target.files[0];

		var chunkSize  = 3 * 1024 * 1024; // bytes

		var fileSize   = file.size;
		var offset     = 0;
		var self       = this; // we need a reference to the current object
		var readBlock  = null;
		var startDate  = new Date();
		
		mp4box 	   = new MP4Box();

		mp4box.onError = function(e) { 
			console.log("mp4box failed to parse data."); 
		};

		var done = false;
		//doesn't get called when there's no mp4 in the data, e.g. other video format like webm
		mp4box.onReady = function (info) {
			console.log("Received File Information");
			done = true; //stop reading all the data, we have what we wanted
			document.getElementById('output').innerHTML = JSON.stringify(info);

			var max = 1500*1024;
			var target = 1000*1024;
			//FIXME: videos with no audio or just audio, so either video or audio, are not supported currently
			//       -> they crash
			var overall_bitrate = info.videoTracks[0].bitrate + info.audioTracks[0].bitrate;
			var audioCodec = info.audioTracks[0].codec;
			var videoCodec = info.videoTracks[0].codec;
			document.getElementById('bitratetext').innerHTML = overall_bitrate / 1000 |0;
			document.getElementById('audiotext').innerHTML = audioCodec;
			document.getElementById('videotext').innerHTML = videoCodec;

			var msg = document.getElementById('checkmsg');
			var allowed = true;
			msg.innerHTML = '';
			if(!info.isProgressive){
				msg.innerHTML += "The video file is not progressive. ";
				allowed = false;
			}
			if(info.audioTracks.length > 1){
				msg.innerHTML += "There's more than one audio track. ";
				allowed = false;
			}
			if(info.videoTracks.length > 1){
				msg.innerHTML += "There's more than one video track. ";
				allowed = false;
			}
			if(overall_bitrate > max){
				msg.innerHTML += "Your video file exceeds the maximum bitrate. ";
				allowed = false;
			}else if(overall_bitrate > target){
				msg.innerHTML += "WARNING: Your video file exceeds the recommended bitrate. Try to make smaller files. ";
			}
			if(audioCodec != 'mp4a'){
				msg.innerHTML += "The audio codec isn't supported. ";
				allowed = false;
			}
			if(!videoCodec.startsWith('avc1')){
				msg.innerHTML += "The video codec isn't supported. ";
				allowed = false;
			}
			if(!allowed){
				msg.innerHTML += "You are not allowed to upload this file.";
			}
		}

		var onparsedbuffer = function(mp4box, buffer) {
			console.log("Appending buffer with offset "+offset);
			buffer.fileStart = offset;
			mp4box.appendBuffer(buffer);
		}

		var onBlockRead = function(evt) {
			if (evt.target.error == null) {
				onparsedbuffer(mp4box, evt.target.result); // callback for handling read chunk
				offset += evt.target.result.byteLength;
			} else {
				console.log("Read error: " + evt.target.error);
				return;
			}
			if (offset >= fileSize) {
				var endRead = new Date();
				console.log("Done reading file ("+fileSize+ " bytes) in "+(endRead - startDate)+" ms");
				console.log("Done constructing tree in "+(new Date() - endRead)+" ms");
				if(!done){
					document.getElementById('checkmsg').innerHTML = "No mp4 file found. You are not allowed to upload this file.";
				}
				return;
			}

			if(!done){
				readBlock(offset, chunkSize, file);
			}
		}

		readBlock = function(_offset, length, _file) {
			var r = new FileReader();
			var blob = _file.slice(_offset, length + _offset);
			r.onload = onBlockRead;
			r.readAsArrayBuffer(blob);
		}

		readBlock(offset, chunkSize, file);
	}, false);
</script>
